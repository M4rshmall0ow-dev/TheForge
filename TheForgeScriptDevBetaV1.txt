local success, WindUI =
    pcall(
    function()
        return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
    end
)
if not success or not WindUI then
    warn("failed to load WindUI")
    return
end

themeNames = {
    "Ocean Blue",
    "Forest Green",
    "Minimal Light",
    "Retro Purple",
    "Sunset",
    "Neon Pulse",
    "Steel Phantom",
    "Vaporwave",
    "Deep Sea",
    "Sepia Warmth",
    "Monokai Dark",
    "Solarized Light",
    "Cherry Blossom",
    "Charcoal Gold",
    "Icy Mint",
    "Volcano",
    "Amethyst",
    "Pastel Dream",
    "Coffee Shop",
    "Cyberpunk Red"
}

themeColors = {
    ["Ocean Blue"] = {
        Accent = "#0B5394",
        Dialog = "#0A3D6B",
        Outline = "#6DACEA",
        Text = "#EBF5FF",
        Placeholder = "#85AECF",
        Background = "#051A2E",
        Button = "#1C67A8",
        Icon = "#A9D5FD"
    },
    ["Forest Green"] = {
        Accent = "#1A5E2E",
        Dialog = "#114220",
        Outline = "#8AC79B",
        Text = "#E9FCE9",
        Placeholder = "#79A378",
        Background = "#0A2B14",
        Button = "#2B7A42",
        Icon = "#B3E3C1"
    },
    ["Minimal Light"] = {
        Accent = "#F3F4F6",
        Dialog = "#FFFFFF",
        Outline = "#4B5563",
        Text = "#1F2937",
        Placeholder = "#9CA3AF",
        Background = "#F9FAFB",
        Button = "#E5E7EB",
        Icon = "#4B5563"
    },
    ["Retro Purple"] = {
        Accent = "#7E22CE",
        Dialog = "#4A148C",
        Outline = "#F0ABFC",
        Text = "#FDF4FF",
        Placeholder = "#BC8FDD",
        Background = "#2D0557",
        Button = "#9333EA",
        Icon = "#F0ABFC"
    },
    ["Sunset"] = {
        Accent = "#FF8847",
        Dialog = "#CC5500",
        Outline = "#FFD9C0",
        Text = "#FFF7F0",
        Placeholder = "#FFC099",
        Background = "#331A00",
        Button = "#FF7043",
        Icon = "#FFD9C0"
    },
    ["Neon Pulse"] = {
        Accent = "#00FF00",
        Dialog = "#111111",
        Outline = "#00FFFF",
        Text = "#FFFFFF",
        Placeholder = "#008800",
        Background = "#000000",
        Button = "#39FF14",
        Icon = "#00FFFF"
    },
    ["Steel Phantom"] = {
        Accent = "#404040",
        Dialog = "#262626",
        Outline = "#A3A3A3",
        Text = "#D4D4D4",
        Placeholder = "#737373",
        Background = "#171717",
        Button = "#525252",
        Icon = "#A3A3A3"
    },
    ["Vaporwave"] = {
        Accent = "#FF00FF",
        Dialog = "#1B001B",
        Outline = "#00FFFF",
        Text = "#FFFFFF",
        Placeholder = "#FF69FF",
        Background = "#0A0014",
        Button = "#E75480",
        Icon = "#00FFFF"
    },
    ["Deep Sea"] = {
        Accent = "#008B8B",
        Dialog = "#005A5A",
        Outline = "#80CBC4",
        Text = "#E0FFFF",
        Placeholder = "#4DB6AC",
        Background = "#003636",
        Button = "#00A3A3",
        Icon = "#80CBC4"
    },
    ["Sepia Warmth"] = {
        Accent = "#7B3F00",
        Dialog = "#5C3200",
        Outline = "#D2B48C",
        Text = "#F5E8D6",
        Placeholder = "#A98F70",
        Background = "#3D291F",
        Button = "#9D5B18",
        Icon = "#D2B48C"
    },
    ["Monokai Dark"] = {
        Accent = "#F92672",
        Dialog = "#272822",
        Outline = "#66D9EF",
        Text = "#F8F8F2",
        Placeholder = "#75715E",
        Background = "#1C1E1A",
        Button = "#A6E22E",
        Icon = "#66D9EF"
    },
    ["Solarized Light"] = {
        Accent = "#268BD2",
        Dialog = "#FDF6E3",
        Outline = "#93A1A1",
        Text = "#586E75",
        Placeholder = "#839496",
        Background = "#EEE8D5",
        Button = "#B58900",
        Icon = "#268BD2"
    },
    ["Cherry Blossom"] = {
        Accent = "#F9BCCB",
        Dialog = "#FFFAFD",
        Outline = "#D96985",
        Text = "#4A1429",
        Placeholder = "#C397A3",
        Background = "#FFF7F9",
        Button = "#E68A9F",
        Icon = "#D96985"
    },
    ["Charcoal Gold"] = {
        Accent = "#FFD700",
        Dialog = "#2C2C2C",
        Outline = "#C0C0C0",
        Text = "#F5F5F5",
        Placeholder = "#6E6E6E",
        Background = "#1D1D1D",
        Button = "#B8860B",
        Icon = "#FFD700"
    },
    ["Icy Mint"] = {
        Accent = "#40E0D0",
        Dialog = "#F0FFFF",
        Outline = "#81D4FA",
        Text = "#004D40",
        Placeholder = "#B2DFDB",
        Background = "#E0FFFF",
        Button = "#80CBC4",
        Icon = "#40E0D0"
    },
    ["Volcano"] = {
        Accent = "#B22222",
        Dialog = "#1C1C1C",
        Outline = "#FF6347",
        Text = "#EBEBEB",
        Placeholder = "#704747",
        Background = "#0A0A0A",
        Button = "#FF4500",
        Icon = "#FF6347"
    },
    ["Amethyst"] = {
        Accent = "#9966CC",
        Dialog = "#36284C",
        Outline = "#CCFF66",
        Text = "#EDE9F2",
        Placeholder = "#8A72A4",
        Background = "#221A33",
        Button = "#7A52AA",
        Icon = "#CCFF66"
    },
    ["Pastel Dream"] = {
        Accent = "#FFB3BA",
        Dialog = "#FAF3E0",
        Outline = "#BAE1FF",
        Text = "#333333",
        Placeholder = "#C1B4A5",
        Background = "#FFFFFF",
        Button = "#BAE1FF",
        Icon = "#FFB3BA"
    },
    ["Coffee Shop"] = {
        Accent = "#795548",
        Dialog = "#F5F5DC",
        Outline = "#A1887F",
        Text = "#3E2723",
        Placeholder = "#BCB0A4",
        Background = "#FFF8E1",
        Button = "#D7CCC8",
        Icon = "#795548"
    },
    ["Cyberpunk Red"] = {
        Accent = "#FF3333",
        Dialog = "#080008",
        Outline = "#33FFFF",
        Text = "#FDFDFD",
        Placeholder = "#771111",
        Background = "#000000",
        Button = "#CC0000",
        Icon = "#33FFFF"
    }
}

for name, colors in pairs(themeColors) do
    WindUI:AddTheme(
        {
            Name = name,
            Accent = Color3.fromHex(colors.Accent),
            Dialog = Color3.fromHex(colors.Dialog),
            Outline = Color3.fromHex(colors.Outline),
            Text = Color3.fromHex(colors.Text),
            Placeholder = Color3.fromHex(colors.Placeholder),
            Background = Color3.fromHex(colors.Background),
            Button = Color3.fromHex(colors.Button),
            Icon = Color3.fromHex(colors.Icon)
        }
    )
end

WindUI:SetTheme("Volcano") -- main color/default color

local function GradientText(text, color1, color2)
    local result = ""
    for i = 1, #text do
        local t = (i - 1) / (#text - 1)
        local r = color1.R + (color2.R - color1.R) * t
        local g = color1.G + (color2.G - color1.G) * t
        local b = color1.B + (color2.B - color1.B) * t
        local hex = string.format("#%02X%02X%02X", r * 255, g * 255, b * 255)
        result = result .. string.format('<font color="%s">%s</font>', hex, text:sub(i, i))
    end
    return result
end

local Window =
    WindUI:CreateWindow(
    {
        Title = "RyZen Hub",
        Icon = "rbxassetid://84501312005643",
        IconThemed = true,
        Author = "By @mallo",
        Size = UDim2.fromOffset(580, 460),
        Resizable = true,
        Transparent = true,
        User = {
            Enabled = true,
            Anonymous = False,
            Callback = function()
                print("clicked")
            end
        }
    }
)

Window:Tag(
    {
        Title = "Mode: Developer",
        Color = Color3.fromHex("#30ff6a"),
        Radius = 10 -- from 0 to 13
    }
)

Window:Tag(
    {
        Title = "v1 MainGui",
        Color = Color3.fromHex("#30ff6a"),
        Radius = 10 -- from 0 to 13
    }
)

Window:SetIconSize(50) -- default is 20

Window:EditOpenButton(
    {
        Title = "RyZen Hub",
        Icon = "rbxassetid://84501312005643",
        CornerRadius = UDim.new(0, 16),
        StrokeThickness = 2,
        Color = ColorSequence.new(Color3.fromHex("ADD8E6"), Color3.fromHex("00008B")), -- gradient
        OnlyMobile = false,
        Enabled = true,
        Draggable = true
    }
)

Window:DisableTopbarButtons({"Close"})

local Info = Window:Tab({Title = "Information", Icon = "info"})

local InviteCode = "KG9ADqwT9Q" -- change to your discord invite
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

local Response
local ErrorMessage = nil

xpcall(
    function()
        Response =
            game:GetService("HttpService"):JSONDecode(
            WindUI.Creator.Request(
                {
                    Url = DiscordAPI,
                    Method = "GET",
                    Headers = {
                        ["Accept"] = "application/json"
                    }
                }
            ).Body
        )
    end,
    function(err)
        warn("err fetching discord info: " .. tostring(err))
        ErrorMessage = tostring(err)
        Response = nil
    end
)

if Response and Response.guild then
    local ParagraphConfig = {
        Title = Response.guild.name,
        Desc = ' <font color="#52525b">•</font> Member Count: ' ..
            tostring(Response.approximate_member_count) ..
                '\n <font color="#16a34a">•</font> Online Count: ' .. tostring(Response.approximate_presence_count),
        Image = "https://cdn.discordapp.com/icons/" ..
            Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=256",
        ImageSize = 42,
        Buttons = {
            {
                Icon = "link",
                Title = "Copy Discord Invite",
                Callback = function()
                    pcall(
                        function()
                            setclipboard("https://discord.gg/" .. InviteCode)
                        end
                    )
                end
            },
            {
                Icon = "refresh-cw",
                Title = "Update Info",
                Callback = function()
                    xpcall(
                        function()
                            local UpdatedResponse =
                                game:GetService("HttpService"):JSONDecode(
                                WindUI.Creator.Request(
                                    {
                                        Url = DiscordAPI,
                                        Method = "GET"
                                    }
                                ).Body
                            )

                            if UpdatedResponse and UpdatedResponse.guild then
                                DiscordInfo:SetDesc(
                                    ' <font color="#52525b">•</font> Member Count: ' ..
                                        tostring(UpdatedResponse.approximate_member_count) ..
                                            '\n <font color="#16a34a">•</font> Online Count: ' ..
                                                tostring(UpdatedResponse.approximate_presence_count)
                                )
                            end
                        end,
                        function(err)
                            warn("err updating discord info: " .. tostring(err))
                        end
                    )
                end
            }
        }
    }

    if Response.guild.banner then
        ParagraphConfig.Thumbnail =
            "https://cdn.discordapp.com/banners/" ..
            Response.guild.id .. "/" .. Response.guild.banner .. ".png?size=256"
        ParagraphConfig.ThumbnailSize = 80
    end

    local DiscordInfo = Info:Paragraph(ParagraphConfig)
else
    Info:Paragraph(
        {
            Title = "Error when receiving information about the Discord server",
            Desc = ErrorMessage or "Unknown error occurred",
            Image = "triangle-alert",
            ImageSize = 26,
            Color = "Red"
        }
    )
end

local GameInfo =
    Info:Paragraph(
    {
        Title = GradientText("PanScript", Color3.fromRGB(173, 216, 230), Color3.fromRGB(0, 0, 139)),
        Desc = "Script made by @mallo",
        Color = "White"
    }
)

local Paragraph =
    Info:Paragraph(
    {
        Title = "Version Beta!",
        Desc = "More features Coming Soon! If you encounted some bugs join our discord to report it!",
        Color = "White"
    }
)

Window:Divider()

local MainTab = Window:Tab({
 Title = "MainFarm",
 Icon = "house"
})

local Section = MainTab:Section({ 
    Title = "Auto Mine",
    Icon = "pickaxe",
})

-- Ore list you provided
local OreTypes = { "Pebble", "Rock", "Boulder", "Basalt Rock", "Volcanic Rock" }

local HttpService = game:GetService("HttpService")

local Dropdown = MainTab:Dropdown({
 Title = "Ore Types",
 Desc = "Select one ore to mine",
 Values = OreTypes,          -- your ore list
 Value = "Pebble",           -- default selected
 Multi = false,              -- single select
 AllowNone = false,          -- must select one
 Callback = function(selected)
  _G.MineTheseOres = { selected }  -- wrap in table to keep rest of script compatible
  print("Selected Ore:", selected)
 end
})

-- set default global selected list if not already set
_G.MineTheseOres = _G.MineTheseOres or { "Pebble" }
local LastNoOreNotify = 0

local Toggle = MainTab:Toggle({
  Title = "Auto Mine",
  Desc = "Auto mine selected ores",
  Icon = "pickaxe",
  Type = "Checkbox",
  Value = false,
  Callback = function(state)
    _G.AutoMine = state
    print("Auto Mine:", state)
    if state then
      -- notify only when disabled
      pcall(function()
        WindUI:Notify({
          Title = "Auto Mine Enabled",
          Content = "mining started",
          Duration = 3,
          Icon = "bird",
        })
      end)
    end
  end
})

local Slider = MainTab:Slider({
  Title = "Tween Speed",
  Desc = "Adjust how fast the player moves to the ore (Slower = Safer)",
 
  Step = 1, -- increment step
  Value = {
    Min = 1,      -- minimum speed
    Max = 100,     -- maximum speed
    Default = 67,  -- starting value
  },
  Callback = function(value)
    _G.TweenSpeed = value  -- store in a global variable
    print("Tween Speed set to:", value)
  end
})

-- ======= AUTO MINER =======
local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Player = Players.LocalPlayer
local TweenService = game:GetService("TweenService")

-- safe attempt to get remote; don't error if not found
local MineRemote
pcall(function()
 if RS and RS:FindFirstChild("Shared") and RS.Shared:FindFirstChild("Packages") then
  local ok, v = pcall(function()
   return RS.Shared.Packages.Knit.Services.ToolService.RF.ToolActivated
  end)
  if ok and v then MineRemote = v end
 end
end)

_G.AutoMine = _G.AutoMine or false
_G.MineTheseOres = _G.MineTheseOres or { "Pebble" }

-- Zones: adjust names if needed
if not Workspace:FindFirstChild("Rocks") then
 warn("Workspace.Rocks not found - adjust zone names")
end
local Rocks = Workspace:FindFirstChild("Rocks")
local function safeWaitFor(name)
 if not Rocks then return nil end
 local ok, res = pcall(function() return Rocks:WaitForChild(name, 2) end)
 if ok then return res end
 return nil
end

local RockZones = {}
do
 local z1 = safeWaitFor("Island1CaveStart")
 local z2 = safeWaitFor("Island1CaveMid")
 local z3 = safeWaitFor("Island1CaveDeep")
 if z1 then table.insert(RockZones, z1) end
 if z2 then table.insert(RockZones, z2) end
 if z3 then table.insert(RockZones, z3) end
end

local Character = Player.Character or Player.CharacterAdded:Wait()
local Root = Character:WaitForChild("HumanoidRootPart")

Player.CharacterAdded:Connect(function()
 task.wait(0.5)
 Character = Player.Character
 Root = Character:WaitForChild("HumanoidRootPart")
end)

local CurrentOre = nil
local LastTeleportedOre = nil
local TELEPORT_DISTANCE = 8 -- if you move farther than this, tp back

local function GetBase(ore)
 if not ore then return nil end
 if ore:IsA("BasePart") then return ore end
 if ore.PrimaryPart then return ore.PrimaryPart end
 return ore:FindFirstChildWhichIsA("BasePart")
end

local function OreHealth(ore)
 if not ore then return nil end
 local ok, hp = pcall(function() return ore:GetAttribute("Health") end)
 if ok and type(hp) == "number" then return hp end
 local base = GetBase(ore)
 if base then
  local ok2, hp2 = pcall(function() return base:GetAttribute("Health") end)
  if ok2 and type(hp2) == "number" then return hp2 end
  local child = base:FindFirstChild("Health")
  if child and child.Value ~= nil then return tonumber(child.Value) end
 end
 local topchild = ore:FindFirstChild("Health")
 if topchild and topchild.Value ~= nil then return tonumber(topchild.Value) end
 return nil
end

local function IsValidOre(ore)
 if not ore or not ore.Name then return false end
 for _, name in ipairs(_G.MineTheseOres or {}) do
  if string.find(string.lower(ore.Name), string.lower(name), 1, true) or string.find(string.lower(ore.Name), string.lower(name)) then
   return true
  end
 end
 return false
end

local function GetClosestOre()
 local nearest, bestDist = nil, math.huge
 for _, zone in ipairs(RockZones) do
  if not zone then
   -- skip missing zone
  else
   for _, cand in ipairs(zone:GetDescendants()) do
    if cand and (cand:IsA("Model") or cand:IsA("BasePart")) and IsValidOre(cand) then
     local base = GetBase(cand)
     if base then
      local hp = OreHealth(cand)
      if hp and hp > 0 then
       local ok, pos = pcall(function() return Root.Position end)
       if ok and pos then
        local d = (pos - base.Position).Magnitude
        if d < bestDist then
         bestDist = d
         nearest = cand
        end
       end
      end
     end
    end
   end
  end
 end
 return nearest
end

-- 1 Freeze/unfreeze player
local FreezeActive = false
local function SetFreeze(state)
    if FreezeActive == state then return end
    FreezeActive = state

    local Character = Player.Character
    if not Character then return end
    local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
    local Root = Character:FindFirstChild("HumanoidRootPart")

    if Humanoid and Root then
        if state then
            -- Freeze movement but DO NOT anchor Root!
            Humanoid.WalkSpeed = 0
            Humanoid.JumpPower = 0
            Humanoid.AutoRotate = false
        else
            -- Restore normal movement
            Humanoid.WalkSpeed = 16
            Humanoid.JumpPower = 50
            Humanoid.AutoRotate = true
        end
    end
end

-- updates freeze based on current ore and AutoMine toggle
local function UpdateFreeze()
  if _G.AutoMine and CurrentOre then
    SetFreeze(true)   -- freeze only while auto-mining a valid ore
  else
    SetFreeze(false)  -- unfreeze otherwise
  end
end

local function SetNoclip(state)
  local Character = Player.Character
  if not Character then return end
  for _, part in ipairs(Character:GetDescendants()) do
    if part:IsA("BasePart") and part.CanCollide ~= nil then
      part.CanCollide = not state
    end
  end
end

local TweenService = game:GetService("TweenService")

local function MoveToOre(ore)
  local base = GetBase(ore)
  if not base then return end

  SetNoclip(true)

  -- side offset
  local offsetDistance = 5
  local directionToOre = (base.Position - Root.Position).Unit
  local perpendicular = Vector3.new(-directionToOre.Z, 0, directionToOre.X)
  local sidePos = base.Position + perpendicular * offsetDistance

  -- RAYCAST DOWN TO FIND REAL GROUND HEIGHT
  local rayParams = RaycastParams.new()
  rayParams.FilterDescendantsInstances = {Character}
  rayParams.FilterType = Enum.RaycastFilterType.Blacklist

  local rayResult = workspace:Raycast(
    sidePos + Vector3.new(0, 10, 0),  -- start above
    Vector3.new(0, -50, 0),          -- cast downward
    rayParams
  )

  local finalY = sidePos.Y
  if rayResult then
    finalY = rayResult.Position.Y + 3 -- put feet exactly above ground
  end

  local targetPos = Vector3.new(sidePos.X, finalY, sidePos.Z)

  -- FACE THE ORE
  local goalCFrame = CFrame.new(targetPos, base.Position)

  local distance = (Root.Position - targetPos).Magnitude
  local speed = _G.TweenSpeed or 67
  local tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)

  local tween = TweenService:Create(Root, tweenInfo, {CFrame = goalCFrame})
  tween:Play()
  tween.Completed:Wait()

  SetNoclip(false)
end

local function TeleportToOreOnce(ore)
  if not ore then return end
  if LastTeleportedOre == ore then return end
  MoveToOre(ore)
  LastTeleportedOre = ore
end

local function TryMineSafe()
 if not MineRemote then
  -- remote not found; attempt to call via path just-in-time (best-effort)
  pcall(function()
   local rr = RS.Shared and RS.Shared.Packages and RS.Shared.Packages.Knit and RS.Shared.Packages.Knit.Services and RS.Shared.Packages.Knit.Services.ToolService and RS.Shared.Packages.Knit.Services.ToolService.RF and RS.Shared.Packages.Knit.Services.ToolService.RF.ToolActivated
   if rr then
    pcall(function() rr:InvokeServer("Pickaxe") end)
   end
  end)
  return
 end
 pcall(function() MineRemote:InvokeServer("Pickaxe") end)
end

-- Main loop (no 'continue', compatible with all runtimes)
task.spawn(function()
  while true do
    task.wait(0.12)

    -- AutoMine off  reset
    if not _G.AutoMine then
      CurrentOre = nil
      LastTeleportedOre = nil
      SetFreeze(false)  -- ensure unfreeze
    else
      -- ensure character exists
      if not (Character and Character.Parent and Root and Root.Parent) then
        task.wait(0.4)
        Character = Player.Character or Player.CharacterAdded:Wait()
        Root = Character:FindFirstChild("HumanoidRootPart") or Root
      end

      -- validate current ore
      local hasValid = false
      if CurrentOre and CurrentOre.Parent then
        local hp = OreHealth(CurrentOre)
        if hp and hp > 0 then
          hasValid = true
        else
          CurrentOre = nil
          LastTeleportedOre = nil
        end
      end

      if not hasValid then
        CurrentOre = GetClosestOre()
        LastTeleportedOre = nil

        -- Notify if no ore
        if not CurrentOre then
          local now = tick()
          if now - LastNoOreNotify > 3 then
            LastNoOreNotify = now
            pcall(function()
              WindUI:Notify({
                Title = "No Ores Found",
                Content = "Selected ores are not nearby or do not exist.",
                Duration = 3,
                Icon = "alert-triangle",
              })
            end)
          end
        end
      end

      -- if there is a valid ore
      if CurrentOre then
        local base = GetBase(CurrentOre)
        if base then
          -- teleport/move to ore if needed
          local ok, rootPos = pcall(function() return Root.Position end)
          if ok and rootPos then
            local dist = (rootPos - base.Position).Magnitude
            if (not LastTeleportedOre) or dist > TELEPORT_DISTANCE then
              TeleportToOreOnce(CurrentOre)
              task.wait(0.12) -- small wait after teleport
            end
          else
            TeleportToOreOnce(CurrentOre)
          end

          -- Freeze player while moving and mining
          SetFreeze(true)

          -- Mine
          TryMineSafe()
          task.wait(0.05)

          -- Unfreeze automatically if AutoMine is off or ore is gone
          local hp = OreHealth(CurrentOre)
          if not hp or hp <= 0 then
        
   CurrentOre = nil
            LastTeleportedOre = nil
            SetFreeze(false)
          end
        else
          CurrentOre = nil
          LastTeleportedOre = nil
          SetFreeze(false)
        end
      else
        SetFreeze(false) -- no ore  unfreeze
      end
    end
  end
end)

local Section = MainTab:Section({ 
    Title = "Auto Sell",
    Icon = "circle-dollar-sign",
})

-- Auto Sell + Proximity interaction (WindUI) --
-- Assumes WindUI is available and the same Knit/Service structure you posted earlier.

local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")

local Player = Players.LocalPlayer

-- wait for Knit-like structure (may vary by game; adjust if needed)
local Shared = RS:WaitForChild("Shared")
local Packages = Shared:WaitForChild("Packages")
local Knit = Packages:WaitForChild("Knit")
local ServicesFolder = Knit:WaitForChild("Services")

-- Remote references (pcall-safe later)
local DialogueServiceRemote = nil -- RunCommand InvokeServer
local DialogueEventRemote = nil   -- RE.DialogueEvent:FireServer
local ProximityDialogueRemote = nil -- ProximityService.RF.Dialogue:InvokeServer

-- try to fetch remotes if present (wrap in pcall to avoid hard errors)
pcall(function()
    local DialogueService = ServicesFolder:WaitForChild("DialogueService")
    if DialogueService and DialogueService:FindFirstChild("RF") and DialogueService.RF:FindFirstChild("RunCommand") then
        DialogueServiceRemote = DialogueService.RF.RunCommand
    end
    if DialogueService and DialogueService:FindFirstChild("RE") and DialogueService.RE:FindFirstChild("DialogueEvent") then
        DialogueEventRemote = DialogueService.RE.DialogueEvent
    end
end)

pcall(function()
    local ProxService = ServicesFolder:WaitForChild("ProximityService")
    if ProxService and ProxService:FindFirstChild("RF") and ProxService.RF:FindFirstChild("Dialogue") then
        ProximityDialogueRemote = ProxService.RF.Dialogue
    end
end)

-- Full item list (from you)
local ItemList = {
    "Aite","Amethyst","Arcane Crystal ore","Bananite","Blue Crystal ore","Boneite","Cardboardite","Cobalt",
    "Copper","Crimson Crystal ore","Cuprite","Dark Boneite","Darkryte","Demonite","Diamond","Emerald","Eye Ore",
    "Fichillium","Fireite","Gold","Green Crystal ore","Iron","Lapis Lazuli","Lightite","Magmaite","Magenta Crystal ore",
    "Mushroomite","Mythril","Obsidian","Orange Crystal ore","Platinum","Poopite","Quartz","Rainbow Crystal ore",
    "Rivalite","Ruby","Sand Stone","Sapphire","Silver","Slimite","Stone","Tin","Titanium","Topaz","Uranium","Volcanic Rock"
}

-- Config / globals
_G.AutoSellEnabled = false
_G.ItemsToSell = {}          -- set by dropdown (array of names)
_G.SellAmount = 1            -- set by Input (how many of each to sell per command)
_G.SellDelayMs = 70          -- slider (milliseconds) default 70 ms
local TweenTime = 1.0        -- seconds to tween to target (adjust if desired)
local CloseDistance = 10     -- studs considered "close enough" to Greedy Cey

-- Dropdown: select ores to sell
local Dropdown = MainTab:Dropdown({
    Title = "Select Items to Sell",
    Desc = "Choose items to autosell",
    Values = ItemList,
    Multi = true,
    Value = {},
    Callback = function(selected)
        _G.ItemsToSell = selected
        print("Selected Items:", HttpService:JSONEncode(selected))
    end
})

-- Input: how many items to sell (per item per sell command)
local Input = MainTab:Input({
    Title = "Amount to sell (per item)",
    Desc = "How many items to sell (You must have the exact amount of item in your inventory for it to work!)",
    Value = "1",
    InputIcon = "bird",
    Type = "Input",
    Placeholder = "Enter number (e.g. 1)",
    Callback = function(input)
        local n = tonumber(input)
        if n and n > 0 then
            _G.SellAmount = math.floor(n)
        else
            _G.SellAmount = 1
        end
        print("SellAmount set to:", _G.SellAmount)
    end
})

-- Slider: sell delay in milliseconds
local Slider = MainTab:Slider({
    Title = "Sell delay (ms)",
    Desc = "Delay between each individual sell (milliseconds).",
    Step = 1,
    Value = {
        Min = 20,
        Max = 120,
        Default = 70,
    },
    Callback = function(value)
        _G.SellDelayMs = value
        print("SellDelayMs:", value)
    end
})

-- Helper: safe invoke wrapper
local function safeInvoke(remote, ...)
    if not remote then
        return false, "remote-not-found"
    end
    local ok, res = pcall(function() return remote:InvokeServer() end)
    return ok, res
end

local function safeFire(remote, ...)
    if not remote then
        return false, "remote-not-found"
    end
    local ok, res = pcall(function() return remote:FireServer() end)
    return ok, res
end

-- Helper: tween-teleport to a part (returns true on success)
local function tweenToPart(part)
    if not part or not part:IsA("BasePart") then return false end
    local char = Player.Character
    if not char then return false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    local targetCFrame = part.CFrame + Vector3.new(0, 5, 0)
    local tweenInfo = TweenInfo.new(TweenTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    local completed = false
    tween:Play()
    tween.Completed:Connect(function() completed = true end)

    -- small timeout guard (in case tween gets stuck)
    local start = tick()
    while not completed do
        if tick() - start > TweenTime + 1.5 then break end
        task.wait(0.05)
    end
    return true
end

-- The main auto-sell loop (runs in spawn whenever toggle is enabled)
-- Robust, fully-Lua-compatible Auto-Sell (copy/paste to replace your auto-sell section)

local autoSellCoroutine = nil

-- Config (tweak if needed)
local TWEEN_SECONDS       = 6
local OPEN_RETRIES        = 6
local OPEN_RETRY_WAIT     = 0.6
local SELL_RETRIES        = 4
local SELL_RETRY_WAIT     = 0.2
local CLOSE_RETRIES       = 4
local CLOSE_RETRY_WAIT    = 0.25
local POST_OPEN_WAIT      = 0.45
local POST_SELL_WAIT      = 0.2
local TARGET_POS          = Vector3.new(-111.74201965332031, 37.50104522705078, -38.12355422973633)

-- Helper: discover Proximity Dialogue remote (safe)
local function getProximityDialogueRemote()
    if ProximityDialogueRemote then return ProximityDialogueRemote end
    local ok, remote = pcall(function()
        return RS and RS.Shared and RS.Shared.Packages and RS.Shared.Packages.Knit and
               RS.Shared.Packages.Knit.Services and RS.Shared.Packages.Knit.Services.ProximityService and
               RS.Shared.Packages.Knit.Services.ProximityService.RF and
               RS.Shared.Packages.Knit.Services.ProximityService.RF.Dialogue
    end)
    if ok and remote then
        ProximityDialogueRemote = remote
        return remote
    end
    return nil
end

-- Helper: discover Dialogue RunCommand remote (safe)
local function getDialogueRunCommand()
    if DialogueServiceRemote then return DialogueServiceRemote end
    local ok, remote = pcall(function()
        return RS and RS.Shared and RS.Shared.Packages and RS.Shared.Packages.Knit and
               RS.Shared.Packages.Knit.Services and RS.Shared.Packages.Knit.Services.DialogueService and
               RS.Shared.Packages.Knit.Services.DialogueService.RF and
               RS.Shared.Packages.Knit.Services.DialogueService.RF.RunCommand
    end)
    if ok and remote then
        DialogueServiceRemote = remote
        return remote
    end
    return nil
end

-- Helper: discover Dialogue Event remote (safe)
local function getDialogueEventRemote()
    if DialogueEventRemote then return DialogueEventRemote end
    local ok, remote = pcall(function()
        return RS and RS.Shared and RS.Shared.Packages and RS.Shared.Packages.Knit and
               RS.Shared.Packages.Knit.Services and RS.Shared.Packages.Knit.Services.DialogueService and
               RS.Shared.Packages.Knit.Services.DialogueService.RE and
               RS.Shared.Packages.Knit.Services.DialogueService.RE.DialogueEvent
    end)
    if ok and remote then
        DialogueEventRemote = remote
        return remote
    end
    return nil
end

-- Open dialogue with retries
local function openDialogueWithRetries()
    local proxRemote = getProximityDialogueRemote()
    if not proxRemote then
        warn("[AutoSell] Proximity Dialogue remote not found.")
        return false, "no-prox-remote"
    end
    local part = workspace.Proximity and workspace.Proximity["Greedy Cey"]
    if not part then
        warn("[AutoSell] workspace.Proximity['Greedy Cey'] not found.")
        return false, "no-part"
    end

    for i = 1, OPEN_RETRIES do
        if not _G.AutoSellEnabled then
            return false, "stopped"
        end
        local ok, res = pcall(function()
            return proxRemote:InvokeServer(part)
        end)
        if ok and res ~= false then
            return true, res
        end
        task.wait(OPEN_RETRY_WAIT)
    end
    return false, "timeout"
end

-- Sell one item with retries
local function doSellWithRetries(itemName, amount)
    local runRemote = getDialogueRunCommand()
    if not runRemote then
        warn("[AutoSell] RunCommand remote not found; cannot sell:", itemName)
        return false, "no-run-remote"
    end

    local basket = {}
    basket[itemName] = amount or 1

    for i = 1, SELL_RETRIES do
        if not _G.AutoSellEnabled then
            return false, "stopped"
        end
        local ok, res = pcall(function()
            return runRemote:InvokeServer("SellConfirm", { ["Basket"] = basket })
        end)
        if ok then
            return true, res
        end
        task.wait(SELL_RETRY_WAIT)
    end
    return false, "sell-failed"
end

-- Close dialogue with retries (tries event then RunCommand fallback)
local function closeDialogueWithRetries()
    local ev = getDialogueEventRemote()
    if ev then
        for i = 1, CLOSE_RETRIES do
            if not _G.AutoSellEnabled then
                return false, "stopped"
            end
            local ok, _ = pcall(function()
                ev:FireServer("Closed")
            end)
            if ok then
                return true
            end
            task.wait(CLOSE_RETRY_WAIT)
        end
    end

    local run = getDialogueRunCommand()
    if run then
        for i = 1, CLOSE_RETRIES do
            if not _G.AutoSellEnabled then
                return false, "stopped"
            end
            local ok, _ = pcall(function()
                run:InvokeServer("Close")
            end)
            if ok then
                return true
            end
            task.wait(CLOSE_RETRY_WAIT)
        end
    end

    return false, "close-failed"
end

-- Tween player to target position (safe)
local function tweenToTarget()
    local char = Player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local ok, _ = pcall(function()
        local tweenInfo = TweenInfo.new(TWEEN_SECONDS, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(hrp, tweenInfo, { CFrame = CFrame.new(TARGET_POS) })
        tween:Play()
        tween.Completed:Wait()
    end)
    return ok
end

-- Ensure player near the target (wait guard)
local function ensurePlayerAtTarget(waitTimeout)
    local char = Player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local start = tick()
    while _G.AutoSellEnabled and (hrp.Position - TARGET_POS).Magnitude > 3 do
        if waitTimeout and tick() - start > waitTimeout then break end
        task.wait(0.15)
    end
    return true
end

-- Tween return position after selling
local RETURN_POS = Vector3.new(-142.3625030517578, 26.04539680480957, 64.44760131835938)
local RETURN_TWEEN_TIME = 2.0 -- seconds

-- Main start function (drop-in updated version)
local function startAutoSellLoop()
  if autoSellCoroutine then return end
  autoSellCoroutine = coroutine.create(function()
    while _G.AutoSellEnabled do
      -- 1) tween to target (Greedy Cey)
      pcall(function() tweenToTarget() end)
      task.wait(POST_OPEN_WAIT)

      -- 2) open dialogue
      local opened, openRes = openDialogueWithRetries()
      if opened then
        -- ensure near target
        ensurePlayerAtTarget(2.5)
        task.wait(POST_OPEN_WAIT)

        -- 3) sell each selected item
        if _G.ItemsToSell and #_G.ItemsToSell > 0 then
          for _, itemName in ipairs(_G.ItemsToSell) do
            if not _G.AutoSellEnabled then break end
            local ok, res = doSellWithRetries(itemName, _G.SellAmount or 1)
            if not ok then
              warn("[AutoSell] failed to sell", itemName, res)
            end
            task.wait(((_G.SellDelayMs or 70) / 1000) + POST_SELL_WAIT)
          end
        else
          task.wait(0.5)
        end

        -- 4) close dialogue + tween back to return position
        local ev = getDialogueEventRemote()
        local run = getDialogueRunCommand()

        -- Attempt to close via Event first
        if ev then
          pcall(function() ev:FireServer("Closed") end)
        end

        -- Fallback: RunCommand close
        if run then
          pcall(function() run:InvokeServer("Close") end)
        end

        -- Small delay to ensure dialogue closed
        task.wait(0.25)

        -- Tween player back to RETURN_POS
        local char = Player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
          local tweenInfo = TweenInfo.new(RETURN_TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
          local tween = TweenService:Create(hrp, tweenInfo, {CFrame = CFrame.new(RETURN_POS)})
          tween:Play()
          tween.Completed:Wait()
        end

        task.wait(0.6)
      else
        -- failed to open dialogue: backoff before retry
        warn("[AutoSell] openDialogueWithRetries failed:", openRes)
        task.wait(0.8)
      end

      -- cooldown before next loop
      task.wait(0.2)
    end

    autoSellCoroutine = nil
  end)
  coroutine.resume(autoSellCoroutine)
end

-- Expose start function globally for toggle code to call
_G.StartAutoSellLoop = startAutoSellLoop

MainTab:Toggle({
    Title = "Auto Sell (Enable)",
    Desc = "Automatically Sells Your Chosen Items!",
    Value = false,
    Callback = function(state)
        _G.AutoSellEnabled = state
        print("AutoSellEnabled:", state)
        if state then
            startAutoSellLoop()
        end
    end
})

-- Quick notification helper (WindUI typically has notify; if not, fallback to print)
local function notify(msg)
    if Window and Window.Notify then
        pcall(function() Window:Notify(msg) end)
    else
        print(msg)
    end
end

notify("Auto Sell UI loaded. Select ores, set amount and delay, then toggle Auto Sell.")

local ForgeTab = Window:Tab({
 Title = "Forge",
 Icon = "anvil"
})

-- Minimal Auto-Forge helper
-- Paste into StarterPlayer > StarterPlayerScripts (LocalScript)
-- This script ONLY adds:
-- 1) A button that opens the Forge UI (Proximity -> StartForge)
-- 2) A toggle that auto-completes the Melt minigame (client-side patch)
-- 3) A toggle that auto-completes the Pour minigame (client-side patch)
-- Nothing else.

repeat task.wait() until game:IsLoaded()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
repeat task.wait() until player and player:FindFirstChild("PlayerGui")
local playerGui = player:WaitForChild("PlayerGui")

-- helpers to locate remotes / modules
local function safeFindRF(path)
local node = ReplicatedStorage
for _, n in ipairs(path) do
if not node then return nil end
node = node:FindFirstChild(n)
end
return node
end

local function tryRequireControllerModule(name)
-- tries common locations for ForgeController modules
local controllers = ReplicatedStorage:FindFirstChild("Controllers")
if controllers and controllers:FindFirstChild("ForgeController") then
local mod = controllers.ForgeController:FindFirstChild(name)
if mod and mod:IsA("ModuleScript") then
local ok, m = pcall(require, mod)
if ok and type(m) == "table" then return m, mod end
end
end
local shared = ReplicatedStorage:FindFirstChild("Shared")
if shared and shared:FindFirstChild("Controllers") and shared.Controllers:FindFirstChild("ForgeController") then
local mod = shared.Controllers.ForgeController:FindFirstChild(name)
if mod and mod:IsA("ModuleScript") then
local ok, m = pcall(require, mod)
if ok and type(m) == "table" then return m, mod end
end
end
return nil, nil
end

-- patch management (allow restore)
local patchedModules = {}

local function safePatch(name, overrideFunc)
local moduleTable, moduleScript = tryRequireControllerModule(name)
if not moduleTable then
return false, "module_not_found"
end
if not patchedModules[name] then
patchedModules[name] = moduleTable.Start
end
moduleTable.Start = function(...)
local ok, res = pcall(function() return overrideFunc(moduleTable) end)
if not ok then
warn("Patch override error for", name, res)
-- fallback to original if available
if patchedModules[name] then
return patchedModulesname
end
return nil
end
return res
end
return true
end

local function restorePatch(name)
local moduleTable, moduleScript = tryRequireControllerModule(name)
if not moduleTable then return false end
if patchedModules[name] then
moduleTable.Start = patchedModules[name]
patchedModules[name] = nil
return true
end
return false
end

-- Auto-complete behaviours
local function meltAutoComplete(_, controller, data)
-- If a Melt minigame module Start expects to return (clientTime, inContact)
-- we simulate a short animation then return a clientTime and inContact = true
-- Also ensure any GUI is hidden quickly to avoid stuck visuals.
local gui = playerGui:FindFirstChild("Forge")
if gui and gui:FindFirstChild("MeltMinigame") then
pcall(function()
gui.MeltMinigame.Visible = true
local bar = gui.MeltMinigame:FindFirstChild("Bar", true) or (gui.MeltMinigame.Bar and gui.MeltMinigame.Bar.Area)
if bar and bar:IsA("Frame") then
-- animate visual progress quickly
pcall(function()
TweenService:Create(bar, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Size = UDim2.fromScale(1, bar.Size.Y.Scale)}):Play()
end)
end
task.wait(0.28)
-- hide it to avoid stuck visuals
gui.MeltMinigame.Visible = false
end)
else
-- fallback small wait so server timing isn't thrown off
task.wait(0.25)
end
local clientTime = (data and data.StartTime) or workspace:GetServerTimeNow()
return clientTime, true
end

local function pourAutoComplete(_, controller, data)
local gui = playerGui:FindFirstChild("Forge")
if gui and gui:FindFirstChild("PourMinigame") then
pcall(function()
gui.PourMinigame.Visible = true
local bar = gui.PourMinigame.Timer and gui.PourMinigame.Timer.Bar
if bar and bar:IsA("Frame") then
pcall(function()
TweenService:Create(bar, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Size = UDim2.fromScale(1, bar.Size.Y.Scale)}):Play()
end)
end
task.wait(0.28)
gui.PourMinigame.Visible = false
end)
else
task.wait(0.25)
end
local clientTime = (data and data.StartTime) or workspace:GetServerTimeNow()
return clientTime
end

-- UI: Button - Open Forge UI
MainTab:Button({
Title = "Open Forge UI",
Desc = "Invoke Proximity -> StartForge to open the Forge UI",
Callback = function()
local ProximityRF = safeFindRF({"Shared","Packages","Knit","Services","ProximityService","RF","Forge"}) or safeFindRF({"Controllers","ForgeController","RF","Forge"})
local StartForgeRF = safeFindRF({"Shared","Packages","Knit","Services","ForgeService","RF","StartForge"}) or safeFindRF({"Controllers","ForgeController","RF","StartForge"})
local forgeObject = workspace:FindFirstChild("Proximity") and workspace.Proximity:FindFirstChild("Forge")
if not forgeObject then
warn("[Forge Helper] forge object not found in workspace.Proximity")
return
end
if ProximityRF then
pcall(function() ProximityRF:InvokeServer(forgeObject) end)
task.wait(0.12)
end
if StartForgeRF then
pcall(function() StartForgeRF:InvokeServer(forgeObject) end)
end
print("[Forge Helper] Opened Forge UI (attempted).")
end
})

-- state for toggles
local meltEnabled = false
local pourEnabled = false

-- UI: Toggle - Complete Melt
ForgeTab:Toggle({
Title = "Complete Melt",
Desc = "When enabled, Melt minigame will auto-complete visually",
Type = "Checkbox",
Value = false,
Callback = function(state)
meltEnabled = state
if meltEnabled then
local ok, err = safePatch("MeltMinigame", meltAutoComplete)
if not ok then
warn("[Forge Helper] Unable to patch MeltMinigame:", err or "unknown")
else
print("[Forge Helper] Melt auto-complete ENABLED")
end
else
if restorePatch("MeltMinigame") then
print("[Forge Helper] Melt auto-complete DISABLED")
else
print("[Forge Helper] Melt patch not found/restored")
end
end
end
})

-- UI: Toggle - Complete Pour
ForgeTab:Toggle({
Title = "Complete Pour",
Desc = "When enabled, Pour minigame will auto-complete visually",
Type = "Checkbox",
Value = false,
Callback = function(state)
pourEnabled = state
if pourEnabled then
local ok, err = safePatch("PourMinigame", pourAutoComplete)
if not ok then
warn("[Forge Helper] Unable to patch PourMinigame:", err or "unknown")
else
print("[Forge Helper] Pour auto-complete ENABLED")
end
else
if restorePatch("PourMinigame") then
print("[Forge Helper] Pour auto-complete DISABLED")
else
print("[Forge Helper] Pour patch not found/restored")
end
end
end
})

local AutoHammerEnabled = false

ForgeTab:Toggle({
Title = "Auto Hammer",
Desc = "Automatically completes hammer minigame",
Value = false,
Callback = function(state)
AutoHammerEnabled = state
end
})

task.spawn(function()
while true do
task.wait(0.05)

if not AutoHammerEnabled then
continue
end

local forgeGui = playerGui:FindFirstChild("Forge")    
if not forgeGui then    
    continue    
end    

local hammerUI = forgeGui:FindFirstChild("HammerMinigame")    
if not hammerUI or not hammerUI.Visible then    
    continue    
end    

-- click detector hammer (the rock/anvil)    
local debris = workspace:FindFirstChild("Debris")    
if not debris then    
    continue    
end    

for _, obj in ipairs(debris:GetChildren()) do    
    if obj:FindFirstChild("ClickDetector") then    
        pcall(function()    
            fireclickdetector(obj.ClickDetector)    
        end)    
    end    
end

end

end)

-- VERY SIMPLE Auto-Perfect for Hammer minigame
-- toggles a patch that makes each note auto-return true (perfect) at the correct timing
local HammerPerfectEnabled = false
local _orig_Hammer_CreateNote = nil

ForgeTab:Toggle({
    Title = "Auto-Perfect Hammer",
    Desc = "Automatically 'perfect' each Hammer note (very simple)",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        HammerPerfectEnabled = state

        local moduleTable, moduleScript = tryRequireControllerModule("HammerMinigame")
        if not moduleTable then
            warn("[Forge Helper] HammerMinigame module not found.")
            return
        end

        if HammerPerfectEnabled then
            -- store original if not already stored
            if not _orig_Hammer_CreateNote then
                _orig_Hammer_CreateNote = moduleTable.CreateNote
            end

            -- override CreateNote: wait the note's lifetime->perfect timing, then return true
            moduleTable.CreateNote = function(_, noteData, ...)
                -- fallback lifetime if missing
                local Lifetime = (noteData and noteData.Lifetime) or 1
                -- decompiled module used Lifetime * 25/44 for the "perfect" moment
                local perfectDelay = Lifetime * 25 / 44
                task.wait(perfectDelay)
                -- return true == hit (perfect). Keep it simple.
                return true
            end

            print("[Forge Helper] Hammer auto-perfect ENABLED")
        else
            if _orig_Hammer_CreateNote and moduleTable then
                moduleTable.CreateNote = _orig_Hammer_CreateNote
                _orig_Hammer_CreateNote = nil
                print("[Forge Helper] Hammer auto-perfect DISABLED")
            else
                print("[Forge Helper] Hammer auto-perfect: nothing to restore")
            end
        end
    end
})

print("Forge Helper loaded.")

local MiscTab = Window:Tab({
 Title = "Misc",
 Icon = "cog"
})

local ThemeDropdown =
    MiscTab:Dropdown(
    {
        Title = "Select Theme",
        Values = themeNames,
        Value = "Volcano",
        Callback = function(selectedTheme)
            WindUI:SetTheme(selectedTheme)
        end
    }
)

MiscTab:Toggle(
    {
        Title = "Transparent Window",
        Desc = "Toggle UI transparency on or off",
        Default = false, -- starts off
        Callback = function(state)
            if state then
                Window:ToggleTransparency(true)
            else
                Window:ToggleTransparency(false)
            end
        end
    }
)